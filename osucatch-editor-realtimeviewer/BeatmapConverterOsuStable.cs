using System;
using System.Globalization;
using System.Text;
using Editor_Reader;
using OpenTK.Graphics.OpenGL;
using osu.Game.Beatmaps;
using osu.Game.Beatmaps.ControlPoints;
using osu.Game.Rulesets.Catch.Beatmaps;
using osu.Game.Rulesets.Catch.Objects;
using osu.Game.Rulesets.Catch.UI;

namespace osucatch_editor_realtimeviewer
{

    // C# standard said: C# allows a higher precision type to be used for all floating-point operations.
    // So it's pretty up to the C# compiler, JIT compiler, optimizer, etc... to decide
    // when an intermediate value is rounded and how much precision the value is rounded to.

    // Unfortunately, there are two problems:
    // 1. JIT compiler decided to use FPU to handle intermediate values, running on x87 80-bit extended precision format.
    //    In C#, we don't have access to a C# native format representing this.
    // 2. Assume we have access to an 80-bit float type, and by investigating disassembled osu! stable code
    //    generated by JIT compiler, we can know the underlying process precisely.
    //    After we implement it as-is in C#, our code can still be modified by compiler and optimizer,
    //    and gives floating point mismatch from osu!stable.

    // Floating point errors are small but in osu!catch we can't accept it.
    // osu! rounds value to float and to int everywhere so small errors can eventually grow large.
    // An 1 ms error on time or 1 pixel error on position can make a hyperdash into pixel edge dash,
    // Or make different amounts of tiny droplets then affecting banana positions.
    // If we can accept this, then we can just use lazer because all positions and times still looks the same.

    // We have 3 options:
    // 1. Implement all the arithmetics in C/C++ so there are 80-bit floats and predictable
    //    floating point behaviors.
    // 2. Simulate 80-bit float type using C#.
    // 3. Wrap 80-bit float type in a C/C++ struct and expose it to C#.

    // Option 2 is out of context, it's silly to implement sqrt, atan computing algorithms in this project.
    // Option 3 is universal, only need to build the library once, but can make performace issues.
    // So we just go for option 1.

    // In StableCompatLib directory, run build.bat to build the dll file and copy it to the directory this program runs.
    public partial class BeatmapConverterOsuStable : BeatmapConverter
    {

        public override List<PalpableCatchHitObject> GetPalpableObjects(IBeatmap beatmap)
        {
            Log.ConsoleLog("Building hitobjects.", Log.LogType.BeatmapConverter, Log.LogLevel.Debug);

            List<PalpableCatchHitObject> palpableObjects = new List<PalpableCatchHitObject>();
            HitObjectManagerCatch manager = new();

            foreach (var currentObject in beatmap.HitObjects)
            {
                if (currentObject is Fruit fruitObject)
                {
                    palpableObjects.Add(fruitObject);
                }
                else if (currentObject is JuiceStream)
                {
                    foreach (var juice in manager.ConvertSlider(beatmap, (JuiceStream)currentObject))
                    {
                        if (juice is PalpableCatchHitObject palpableObject)
                        {
                            juice.ApplyDefaults(beatmap.ControlPointInfo, beatmap.Difficulty);
                            palpableObjects.Add(palpableObject);
                        }
                    }
                }
                else if (currentObject is BananaShower)
                {
                    foreach (var banana in manager.ConvertSpinner(beatmap, (BananaShower)currentObject))
                    {
                        if (banana is PalpableCatchHitObject palpableObject)
                            palpableObjects.Add(palpableObject);
                    }
                }
            }

            palpableObjects.Sort((h1, h2) => h1.StartTime.CompareTo(h2.StartTime));

            // The precise value of catcherWidth in stable depends on window resolution due to floating-point errors.
            // Here we just use a simplified formula so catcherWidth only depends on beatmap CircleSize. 
            initialiseHyperDash((float)(106.75f * (1.7f - 0.14f * beatmap.Difficulty.CircleSize)), palpableObjects);

            return palpableObjects;
        }

        public string BuildConversionMapping(IBeatmap beatmap)
        {
            Log.ConsoleLog("Building hitobjects.", Log.LogType.BeatmapConverter, Log.LogLevel.Debug);

            List<(osu.Game.Rulesets.Objects.HitObject original, List<PalpableCatchHitObject> converted)> palpableObjects
                = new List<(osu.Game.Rulesets.Objects.HitObject original, List<PalpableCatchHitObject> converted)>();
            HitObjectManagerCatch manager = new();

            foreach (var currentObject in beatmap.HitObjects)
            {
                List<PalpableCatchHitObject> currentObjectConvert = new List<PalpableCatchHitObject>();
                if (currentObject is Fruit fruitObject)
                {
                    currentObjectConvert = [fruitObject];
                }
                else if (currentObject is JuiceStream)
                {
                    currentObjectConvert = manager.ConvertSlider(beatmap, (JuiceStream)currentObject);
                }
                else if (currentObject is BananaShower)
                {
                    currentObjectConvert = manager.ConvertSpinner(beatmap, (BananaShower)currentObject);
                }
                palpableObjects.Add(new(currentObject, currentObjectConvert));
            }

            palpableObjects.Sort((h1, h2) => h1.original.StartTime.CompareTo(h2.original.StartTime));

            List<PalpableCatchHitObject> plainPalpableObjects = new List<PalpableCatchHitObject>();
            foreach (var objectConvert in palpableObjects)
            {
                foreach (var converted in objectConvert.converted)
                {
                    plainPalpableObjects.Add(converted);
                }
            }
            initialiseHyperDash((float)(106.75f * (1.7f - 0.14f * beatmap.Difficulty.CircleSize)), plainPalpableObjects);

            StringBuilder conversionMapping = new StringBuilder();
            conversionMapping.AppendLine("{");
            conversionMapping.AppendLine("""    "Mappings": [""");
            conversionMapping.AppendJoin(",\n", palpableObjects.Select(objectConvert =>
            {
                string subObjectString = string.Join(",\n", objectConvert.converted.Select(hitObject => $$"""
                                {
                                    "StartTime": {{doubleToString(hitObject.StartTime)}},
                                    "Position": {{floatToString(hitObject.EffectiveX)}},
                                    "#=zvnXjJz7N45MN": {{(hitObject.HyperDash ? "true" : "false")}}
                                }
                """));
                return $$"""
                        {
                            "StartTime": {{doubleToString(objectConvert.original.StartTime)}},
                            "Objects": [
                {{subObjectString}}
                            ]
                        }
                """;
            }));
            conversionMapping.AppendLine();
            conversionMapping.AppendLine("    ]");
            conversionMapping.AppendLine("}");
            return conversionMapping.ToString();
        }

        private static string doubleToString(double value)
        {
            string current = value.ToString("G17", CultureInfo.InvariantCulture);
            if (!double.IsNaN(value) && !double.IsInfinity(value) && current.IndexOf('.') == -1 && current.IndexOf('E') == -1 && current.IndexOf('e') == -1)
            {
                current += ".0";
            }
            return current;
        }

        private static string floatToString(float value)
        {
            string current = value.ToString("G9", CultureInfo.InvariantCulture); ;
            if (!float.IsNaN(value) && !float.IsInfinity(value) && current.IndexOf('.') == -1 && current.IndexOf('E') == -1 && current.IndexOf('e') == -1)
            {
                current += ".0";
            }
            return current;
        }

        private static void initialiseHyperDash(float catcherWidth, List<PalpableCatchHitObject> hitObjects)
        {
            var palpableObjects = CatchBeatmap.GetPalpableObjects(hitObjects)
                                              .Where(h => h is Fruit || (h is Droplet && h is not TinyDroplet))
                                              .ToArray();

            float halfCatcherWidth = catcherWidth / 2;

            int lastDirection = 0;
            float lastExcess = halfCatcherWidth;

            for (int i = 0; i < palpableObjects.Length - 1; i++)
            {
                var currentObject = palpableObjects[i];
                var nextObject = palpableObjects[i + 1];

                // Reset variables in-case values have changed (e.g. after applying HR)
                currentObject.HyperDashTarget = null;
                currentObject.DistanceToHyperDash = 0;

                int thisDirection = nextObject.EffectiveX > currentObject.EffectiveX ? 1 : -1;

                // Int truncation added to match osu!stable.
                float timeToNext = (int)nextObject.StartTime - (int)currentObject.StartTime - 1000f / 60f / 4; // 1/4th of a frame of grace time, taken from osu-stable
                float distanceToNext = Math.Abs(nextObject.EffectiveX - currentObject.EffectiveX) - (lastDirection == thisDirection ? lastExcess : halfCatcherWidth);
                float distanceToHyper = timeToNext - distanceToNext;

                if (timeToNext < distanceToNext)
                {
                    currentObject.HyperDashTarget = nextObject;
                    lastExcess = halfCatcherWidth;
                }
                else
                {
                    currentObject.DistanceToHyperDash = distanceToHyper;
                    lastExcess = Math.Clamp(distanceToHyper, 0, halfCatcherWidth);
                }

                lastDirection = thisDirection;
            }
        }

    }
}
