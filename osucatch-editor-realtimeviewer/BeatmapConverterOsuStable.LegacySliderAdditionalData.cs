using System.Runtime.InteropServices;
using osu.Game.Beatmaps;
using osu.Game.Rulesets.Catch.Objects;
using osu.Game.Rulesets.Objects;
using osu.Game.Rulesets.Objects.Types;
using osuTK;

namespace osucatch_editor_realtimeviewer
{
    public partial class BeatmapConverterOsuStable
    {
        // C# standard said: C# allows a higher precision type to be used for all floating-point operations.
        // So it's pretty up to the C# compiler, JIT compiler, optimizer, etc... to decide
        // when an intermediate value is rounded and how much precision the value is rounded to.

        // Unfortunately, there are two problems:
        // 1. JIT compiler decided to use FPU to handle intermediate values, running on x87 80-bit extended precision format.
        //    In C#, we don't have access to a C# native format representing this.
        // 2. Assume we have access to an 80-bit float type, and by investigating disassembled osu! stable code
        //    generated by JIT compiler, we can know the underlying process precisely.
        //    After we implement it as-is in C#, our code can still be modified by compiler and optimizer,
        //    and gives floating point mismatch from osu!stable.

        // Floating point errors are small but in osu!catch we can't accept it.
        // osu! rounds value to float and to int everywhere so small errors can eventually grow large.
        // An 1 ms error on time or 1 pixel error on position can make a hyperdash into pixel edge dash,
        // Or make different amounts of tiny droplets then affecting banana positions.
        // If we can accept this, then we can just use lazer because all positions and times still looks the same.

        // We have 3 options:
        // 1. Implement all the arithmetics in C/C++ so there are 80-bit floats and predictable
        //    floating point behaviors.
        // 2. Simulate 80-bit float type using C#.
        // 3. Wrap 80-bit float type in a C/C++ struct and expose it to C#.

        // Option 2 is out of context, it's silly to implement sqrt, atan computing algorithms in this project.
        // Option 3 is universal, only need to build the library once, but can make performace issues.
        // So we just go for option 1.

        // In StableCompatLib directory, run build.bat to build the dll file and copy it to the directory this program runs.
        private class LegacySliderAdditionalData
        {
            public int SpanCount;

            public int StartTime;

            public int EndTime;

            public Vector2 Position;

            public Vector2 EndPosition;

            public double ExpectedDistance;

            public double Velocity;

            public double CurveLength;

            public Vector2 Position2;

            public List<int> SliderRepeatPoints = new List<int>();

            public List<int> SliderScoreTimingPoints = new List<int>();

            public List<double> CumulativeLengths = new List<double>();

            public List<Segment> CurveSegmentPath = new List<Segment>();

            public LegacySliderAdditionalData(IBeatmap beatmap, JuiceStream slider)
            {
                StartTime = (int)slider.StartTime;
                Position = new(slider.OriginalX, slider.Y);

                compute(beatmap, slider);
            }

            private static double computeVelocity(
                double timingBeatLength,
                double sliderVelocityAsBeatLength,
                double difficultySliderTickRate,
                double sliderComboPointDistance)
            {
                float mult = (float)(-(float)(sliderVelocityAsBeatLength) / 100f);
                double beatLength = timingBeatLength * mult;
                return (sliderComboPointDistance * difficultySliderTickRate) * (1000.0 / beatLength);
            }

            [DllImport("StableCompatLib.dll", EntryPoint = "computeVelocity")]
            private static extern double computeVelocityStableCompat(
                double timingBeatLength,
                double sliderVelocityAsBeatLength,
                double difficultySliderTickRate,
                double sliderComboPointDistance);

            private static Vector2 Normalize(Vector2 v)
            {
                float lengthSquared = v.X * v.X + v.Y * v.Y;
                float lengthInverted = 1f / (float)Math.Sqrt(lengthSquared);
                Vector2 result;
                result.X = v.X * lengthInverted;
                result.Y = v.Y * lengthInverted;
                return result;
            }

            [DllImport("StableCompatLib.dll", EntryPoint = "normalize")]
            private static extern void NormalizeStableCompat0(float x, float y, out float rx, out float ry);

            private static Vector2 NormalizeStableCompat(Vector2 v)
            {
                Vector2 result;
                NormalizeStableCompat0(v.X, v.Y, out result.X, out result.Y);
                return result;
            }

            // Returns x * t + y * (1 - t).
            [DllImport("StableCompatLib.dll", EntryPoint = "linearInterpolation")]
            private static extern double LinearInterpolation(double x, double y, double t);

            private List<Vector2> rebuildCurvePoints(Vector2 offset, SliderPath path)
            {
                List<Vector2> curvePoints = new();
                for (int i = 0; i < path.ControlPoints.Count; i++)
                {
                    PathControlPoint curvePoint = path.ControlPoints[i];
                    curvePoints.Add(offset + curvePoint.Position);
                    if (i > 0 && curvePoint.Type != null)
                        curvePoints.Add(offset + curvePoint.Position);
                }
                return curvePoints;
            }

            [DllImport("StableCompatLib.dll", EntryPoint = "timeAtLength")]
            private static extern int GetTimeByLength0(float length, int startTime, double velocity);

            public int GetTimeByLength(float length)
            {
                // return (int)(StartTime + (length / Velocity) * 1000);
                return GetTimeByLength0(length, StartTime, Velocity);
            }

            // Returns (current - start) / (end - start).
            [DllImport("StableCompatLib.dll", EntryPoint = "progress")]
            private static extern float Progress(double start, double end, float current);

            // Returns a / (b / c).
            [DllImport("StableCompatLib.dll", EntryPoint = "continuousDivision")]
            private static extern double ContinuousDivision(int a, int b, int c);

            public Vector2 GetPositionByLength(float length)
            {
                if (CurveSegmentPath.Count == 0 || CumulativeLengths.Count == 0)
                    return Position;

                if (length == 0)
                    return CurveSegmentPath[0].Start;

                double end = CumulativeLengths[CumulativeLengths.Count - 1];
                if (length >= end)
                    return CurveSegmentPath[CurveSegmentPath.Count - 1].End;

                int i = CumulativeLengths.BinarySearch(length);
                if (i < 0)
                    i = Math.Min(~i, CumulativeLengths.Count - 1);

                double lengthNext = CumulativeLengths[i];
                double lengthPrevious = i == 0 ? 0 : CumulativeLengths[i - 1];

                Vector2 res = CurveSegmentPath[i].Start;

                if (lengthNext != lengthPrevious)
                {
                    // res += (CurveSegmentPath[i].End - CurveSegmentPath[i].Start) * (float)((length - lengthPrevious) / (lengthNext - lengthPrevious));
                    res += (CurveSegmentPath[i].End - CurveSegmentPath[i].Start) * Progress(lengthPrevious, lengthNext, length);
                }

                return res;
            }

            public Vector2 GetPositionByTime(int time)
            {

                if (time < StartTime || time > EndTime) return Position;

                // float pos = (time - StartTime) / ((float)(EndTime - StartTime) / SpanCount);
                double pos = ContinuousDivision(time - StartTime, EndTime - StartTime, SpanCount);

                if (pos % 2 > 1)
                    pos = 1 - (pos % 1);
                else
                    pos = pos % 1;

                float lengthRequired = (float)(ExpectedDistance * pos);
                return GetPositionByLength(lengthRequired);
            }

            private void compute(IBeatmap beatmap, JuiceStream slider)
            {
                double sliderComboPointDistance = (100 * beatmap.Difficulty.SliderMultiplier) / beatmap.Difficulty.SliderTickRate;

                //Velocity = computeVelocity(
                Velocity = computeVelocityStableCompat(
                    beatmap.ControlPointInfo.TimingPointAt(slider.StartTime).BeatLength,
                    slider.SliderVelocityAsBeatLength,
                    beatmap.Difficulty.SliderTickRate,
                    sliderComboPointDistance
                );

                List<Segment> path = new List<Segment>();

                SliderPath pathData = slider.Path;

                // The first control point should have a non-null PathType
                PathType pathType = pathData.ControlPoints[0].Type ?? PathType.LINEAR;
                List<Vector2> curvePoints = rebuildCurvePoints(new Vector2(slider.OriginalX, slider.Y), pathData);

                const int subSegmentCount = 50;

                switch (pathType.Type)
                {
                    case SplineType.Catmull:
                        for (int j = 0; j < curvePoints.Count - 1; j++)
                        {
                            Vector2 v1 = (j - 1 >= 0 ? curvePoints[j - 1] : curvePoints[j]);
                            Vector2 v2 = curvePoints[j];
                            Vector2 v3 = (j + 1 < curvePoints.Count ? curvePoints[j + 1] : v2 + (v2 - v1));
                            Vector2 v4 = (j + 2 < curvePoints.Count ? curvePoints[j + 2] : v3 + (v3 - v2));

                            for (int k = 0; k < subSegmentCount; k++)
                                path.Add(new Segment(
                                    Vector2.CatmullRom(v1, v2, v3, v4, (float)k / subSegmentCount),
                                    Vector2.CatmullRom(v1, v2, v3, v4, (float)(k + 1) / subSegmentCount)
                                ));
                        }
                        break;

                    case SplineType.BSpline:
                        int lastIndex = 0;

                        for (int i = 0; i < curvePoints.Count; i++)
                        {
                            if (beatmap.BeatmapInfo.BeatmapVersion > 6)
                            {
                                bool lastPointInCurrentPart = i < curvePoints.Count - 2 && curvePoints[i] == curvePoints[i + 1];
                                if (lastPointInCurrentPart || i == curvePoints.Count - 1)
                                {
                                    List<Vector2> currentPartControlPoints = curvePoints.GetRange(lastIndex, i - lastIndex + 1);

                                    if (beatmap.BeatmapInfo.BeatmapVersion > 8 && currentPartControlPoints.Count == 2)
                                    {
                                        path.Add(new Segment(currentPartControlPoints[0], currentPartControlPoints[1]));
                                    }
                                    else if (beatmap.BeatmapInfo.BeatmapVersion > 8 && beatmap.BeatmapInfo.BeatmapVersion < 10 && currentPartControlPoints.Count != 2)
                                    {
                                        List<Vector2> bezierPoints = LegacyMathHelper.CreateBezierWrong(currentPartControlPoints);
                                        for (int j = 1; j < bezierPoints.Count; j++)
                                            path.Add(new Segment(bezierPoints[j - 1], bezierPoints[j]));
                                    }
                                    else
                                    {
                                        List<Vector2> bezierPoints = LegacyMathHelper.CreateBezier(currentPartControlPoints);
                                        for (int j = 1; j < bezierPoints.Count; j++)
                                            path.Add(new Segment(bezierPoints[j - 1], bezierPoints[j]));
                                    }
                                    if (lastPointInCurrentPart) i++;
                                    lastIndex = i;
                                }
                            }
                            else
                            {
                                if ((i > 0 && curvePoints[i] == curvePoints[i - 1]) || i == curvePoints.Count - 1)
                                {
                                    List<Vector2> currentPartControlPoints = curvePoints.GetRange(lastIndex, i - lastIndex + 1);
                                    List<Vector2> bezierPoints = LegacyMathHelper.CreateBezier(currentPartControlPoints);
                                    for (int j = 1; j < bezierPoints.Count; j++)
                                        path.Add(new Segment(bezierPoints[j - 1], bezierPoints[j]));
                                    lastIndex = i;
                                }
                            }
                        }
                        break;

                    case SplineType.PerfectCurve:
                        if (curvePoints.Count < 3)
                            goto case SplineType.Linear;
                        if (curvePoints.Count > 3)
                            goto case SplineType.BSpline;

                        Vector2 p1 = curvePoints[0];
                        Vector2 p2 = curvePoints[1];
                        Vector2 p3 = curvePoints[2];

                        if (LegacyMathHelper.IsStraightLineStableCompat(p1, p2, p3))
                        {
                            goto case SplineType.Linear;
                        }

                        Vector2 center;
                        float radius;
                        double startAngle, endAngle;

                        LegacyMathHelper.CircleThroughPointsStableCompat(p1, p2, p3, out center, out radius, out startAngle, out endAngle);

                        CurveLength = Math.Abs((endAngle - startAngle) * radius);
                        int segments = (int)(CurveLength * 0.125f);

                        Vector2 lastPoint = p1;

                        for (int i = 1; i < segments; i++)
                        {
                            double progress = (double)i / (double)segments;

                            // double t = endAngle * progress + startAngle * (1 - progress);
                            double t = LinearInterpolation(endAngle, startAngle, progress);

                            Vector2 newPoint = LegacyMathHelper.CirclePointStableCompat(center, radius, t);
                            path.Add(new Segment(lastPoint, newPoint));

                            lastPoint = newPoint;
                        }

                        path.Add(new Segment(lastPoint, p3));
                        break;

                    case SplineType.Linear:
                        for (int i = 1; i < curvePoints.Count; i++)
                        {
                            path.Add(new Segment(curvePoints[i - 1], curvePoints[i]));
                        }
                        break;
                }

                CurveSegmentPath = path;

                const double LENGTH_EPS = 0.0001;

                CurveLength = 0;
                for (int i = 0; i < path.Count; i++)
                    CurveLength += path[i].Length;
                int expectedComboCount = 0;

                // double tickDistance = (beatmap.BeatmapInfo.BeatmapVersion < 8) ? sliderComboPointDistance :
                //     (sliderComboPointDistance / ((float)(-slider.SliderVelocityAsBeatLength) / 100f));
                double tickDistance = (beatmap.BeatmapInfo.BeatmapVersion < 8) ? sliderComboPointDistance :
                    (sliderComboPointDistance / ((double)((float)(-slider.SliderVelocityAsBeatLength)) / 100.0));

                if (CurveLength > 0)
                {
                    if (pathData.ExpectedDistance == null || pathData.ExpectedDistance == 0)
                    {
                        expectedComboCount = (int)(CurveLength / tickDistance);
                        pathData.ExpectedDistance = CurveLength;
                    }
                    // After previous check, ExpectedDistance should not be null
                    if (tickDistance > pathData.ExpectedDistance)
                        tickDistance = (double)pathData.ExpectedDistance;
                    double cutLength = CurveLength - (double)pathData.ExpectedDistance;
                    while (path.Count > 0)
                    {
                        Segment lastSegment = path[path.Count - 1];
                        float lastSegmentLength = Vector2.Distance(lastSegment.Start, lastSegment.End);

                        if (lastSegmentLength > cutLength + LENGTH_EPS)
                        {
                            if (lastSegment.End != lastSegment.Start)
                            {
                                lastSegment.End = lastSegment.Start + NormalizeStableCompat(lastSegment.End - lastSegment.Start) * (lastSegment.Length - (float)cutLength);
                            }
                            break;
                        }

                        path.Remove(lastSegment);
                        cutLength -= lastSegmentLength;
                    }
                    ExpectedDistance = (double)pathData.ExpectedDistance;
                }

                if (path.Count > 0)
                {
                    if (CumulativeLengths == null) CumulativeLengths = new List<double>(path.Count);
                    else CumulativeLengths.Clear();

                    double totalLength = 0.0;

                    foreach (Segment l in path)
                    {
                        totalLength += l.Length;
                        CumulativeLengths.Add(totalLength);
                    }
                }

                if (path.Count < 1)
                    return;

                {
                    double scoringLengthTotal = 0;
                    double currentTime = StartTime;

                    Vector2 p1 = new Vector2();
                    Vector2 p2 = new Vector2();

                    double scoringDistance = 0;

                    Position2 = path[path.Count - 1].End;

                    SpanCount = HasRepeatsExtensions.SpanCount(slider);
                    for (int i = 0; i < SpanCount; i++)
                    {
                        double distanceRemain = CumulativeLengths[CumulativeLengths.Count - 1];
                        bool skipTick = false;
                        int reverseStartTime = (int)currentTime;

                        double minTickDistanceFromEnd = 0.01 * Velocity;

                        bool reverse = (i % 2) == 1;

                        int start = reverse ? path.Count - 1 : 0;
                        int end = reverse ? -1 : path.Count;
                        int direction = reverse ? -1 : 1;

                        for (int j = start; j != end; j += direction)
                        {
                            Segment l = path[j];
                            float distance = (float)(CumulativeLengths[j] - (j == 0 ? 0 : CumulativeLengths[j - 1]));

                            if (reverse)
                            {
                                p1 = l.End;
                                p2 = l.Start;
                            }
                            else
                            {
                                p1 = l.Start;
                                p2 = l.End;
                            }

                            // It shows multiply -> float to double -> division in code,
                            // but executes as float to double -> multiply -> division.

                            // double duration = 1000F * distance / Velocity;
                            double duration = 1000.0 * (double)distance / Velocity;

                            currentTime += duration;
                            scoringDistance += distance;

                            while (scoringDistance >= tickDistance && !skipTick)
                            {
                                scoringLengthTotal += tickDistance;
                                scoringDistance -= tickDistance;
                                distanceRemain -= tickDistance;

                                skipTick = distanceRemain <= minTickDistanceFromEnd;
                                if (skipTick)
                                    break;

                                int scoreTime = GetTimeByLength((float)scoringLengthTotal);
                                SliderScoreTimingPoints.Add(scoreTime);
                            }
                        }

                        scoringLengthTotal += scoringDistance;
                        SliderScoreTimingPoints.Add(GetTimeByLength((float)scoringLengthTotal));

                        if (skipTick)
                            scoringDistance = 0;
                        else
                        {
                            scoringLengthTotal -= tickDistance - scoringDistance;
                            scoringDistance = tickDistance - scoringDistance;
                        }
                    }

                    EndPosition = p2;
                    EndTime = (int)currentTime;

                    if (SliderScoreTimingPoints.Count > 0)
                        SliderScoreTimingPoints[SliderScoreTimingPoints.Count - 1] = Math.Max(StartTime + (EndTime - StartTime) / 2, SliderScoreTimingPoints[SliderScoreTimingPoints.Count - 1] - 36);

                    SliderRepeatPoints.Clear();
                    int timingPointsPerSegment = SliderScoreTimingPoints.Count / SpanCount;
                    if (timingPointsPerSegment > 0)
                        for (int i = 0; i < SliderScoreTimingPoints.Count - 1; i++)
                            if ((i + 1) % timingPointsPerSegment == 0)
                                SliderRepeatPoints.Add(SliderScoreTimingPoints[i]);
                }
            }
        }

    }
}
